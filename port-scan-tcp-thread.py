import socket
import time
import threading
from queue import Queue
socket.setdefaulttimeout(0.25)
print_lock = threading.Lock()
#We are using the thread locking concept, thread_lock = threading.Lock()
# a print_lock is what is used to prevent "double" modification of shared variables.
#to avoid multiple modification at a time. - allow single thread to access the variable at a time
# this is used so while one thread is using a variable, others cannot access it.
# Once done, the thread releases the print_lock.


target = input('Enter the host to scanned: ') 
t_IP = socket.gethostbyname(target) #method to return hostname
print ('Starting scan on host: ' , t_IP)

def portscan(port):             #Port number is passed as parameter
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        con = s.connect((t_IP, port)) #con attempt each port definded in range with print lock condition
        with print_lock:    # prevent overlapping
            print(port, 'is open')
        con.close()
    except:
        pass

def threader():             #Threader fetches the worker from queue and process it 
    while True:
        worker = q.get()    
        portscan(worker)    #run the portscan with worker in queue
        q.task_done()       #Once the task is completed the q.task_done() method is called.

q = Queue()                 #define q as queue
startTime = time.time()

for x in range(100): # number of allowed threads 
    t = threading.Thread(target=threader)
    t.daemon = True
    t.start()

for worker in range(1, 65535):  #range of port defined worker
    q.put(worker)

q.join()
print ('Time taken:',time.time() - startTime)


    
        
                    
                        
